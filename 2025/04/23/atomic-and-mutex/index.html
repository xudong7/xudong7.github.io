<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="atomic and mutexatomic in GCC_sync_fetch_and_add_sync_fetch_and_sub_sync_val_compare_and_swap… atomic in Cuse _Atomic to define atomic variable 1234567891011121314151617181920212223#include &lt;stdio.">
<meta property="og:type" content="article">
<meta property="og:title" content="atomic and mutex">
<meta property="og:url" content="https://xudong7.github.io/2025/04/23/atomic-and-mutex/index.html">
<meta property="og:site_name" content="Dunjia&#39;s Blog">
<meta property="og:description" content="atomic and mutexatomic in GCC_sync_fetch_and_add_sync_fetch_and_sub_sync_val_compare_and_swap… atomic in Cuse _Atomic to define atomic variable 1234567891011121314151617181920212223#include &lt;stdio.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xudong7.github.io/images/image34.png">
<meta property="article:published_time" content="2025-04-23T12:29:49.000Z">
<meta property="article:modified_time" content="2025-04-23T13:14:25.636Z">
<meta property="article:author" content="Dunjia">
<meta property="article:tag" content="lock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xudong7.github.io/images/image34.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>atomic and mutex</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/xudong7?tab=repositories">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/04/22/leetcode-49/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://xudong7.github.io/2025/04/23/atomic-and-mutex/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&text=atomic and mutex"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&is_video=false&description=atomic and mutex"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=atomic and mutex&body=Check out this article: https://xudong7.github.io/2025/04/23/atomic-and-mutex/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&name=atomic and mutex&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&t=atomic and mutex"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-and-mutex"><span class="toc-number">1.</span> <span class="toc-text">atomic and mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-in-GCC"><span class="toc-number">2.</span> <span class="toc-text">atomic in GCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-in-C"><span class="toc-number">3.</span> <span class="toc-text">atomic in C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-in-C-1"><span class="toc-number">4.</span> <span class="toc-text">atomic in C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-and-mutex"><span class="toc-number">5.</span> <span class="toc-text">pthread and mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#experiment-to-test-different-lock"><span class="toc-number">6.</span> <span class="toc-text">experiment to test different lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#use-mutex"><span class="toc-number">6.1.</span> <span class="toc-text">use mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-rwlock"><span class="toc-number">6.2.</span> <span class="toc-text">use rwlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-spinlock"><span class="toc-number">6.3.</span> <span class="toc-text">use spinlock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conclusion"><span class="toc-number">7.</span> <span class="toc-text">conclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linklist-example"><span class="toc-number">8.</span> <span class="toc-text">linklist example</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        atomic and mutex
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Dunjia</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-04-23T12:29:49.000Z" class="dt-published" itemprop="datePublished">2025-04-23</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/lock/" rel="tag">lock</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="atomic-and-mutex"><a href="#atomic-and-mutex" class="headerlink" title="atomic and mutex"></a>atomic and mutex</h2><h2 id="atomic-in-GCC"><a href="#atomic-in-GCC" class="headerlink" title="atomic in GCC"></a>atomic in GCC</h2><p><code>_sync_fetch_and_add</code><br><code>_sync_fetch_and_sub</code><br><code>_sync_val_compare_and_swap</code><br>…</p>
<h2 id="atomic-in-C"><a href="#atomic-in-C" class="headerlink" title="atomic in C"></a>atomic in C</h2><p>use <code>_Atomic</code> to define atomic variable</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="keyword">_Atomic</span> <span class="type">int</span> <span class="type">atomic_count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">runner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="type">atomic_count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadIDs[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threadIDs[i], <span class="literal">NULL</span>, runner, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        pthread_join(threadIDs[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The atomic counter is %u\n&quot;</span>, <span class="type">atomic_count</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The non-atomic counter is %u\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>after compile and run, the result is:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc _atomic.c -o _atomic</span><br><span class="line">$ ./_atomic</span><br><span class="line">The atomic counter is 16000000</span><br><span class="line">The non-atomic counter is 5270623</span><br></pre></td></tr></table></figure>

<h2 id="atomic-in-C-1"><a href="#atomic-in-C-1" class="headerlink" title="atomic in C++"></a>atomic in C++</h2><p>use <code>std::atomic&lt;T&gt;</code> to define atomic variable</p>
<p>the <code>exchange</code> function can be used to set the value of atomic variable and return the old value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span> <span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">winner</span> <span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">count1m</span> <span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;&#125;                  <span class="comment">// wait for the ready signal</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; ++i) &#123;&#125;   <span class="comment">// go!, count to 1 million</span></span><br><span class="line">    <span class="keyword">if</span> (!winner.<span class="built_in">exchange</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; won!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadIDs[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> ids[<span class="number">10</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;spawning 10 threads that count to 1 million...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ids[i] = i;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threadIDs[i], <span class="literal">NULL</span>, count1m, (<span class="type">void</span>*)&amp;ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threadIDs[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p.s. at first, winner is false, when the first thread call <code>exchange</code>, it will set winner to true and return false, so the first thread will print “won”, and the other threads will not print anything because the value of winner is already true.</p>
<h2 id="pthread-and-mutex"><a href="#pthread-and-mutex" class="headerlink" title="pthread and mutex"></a>pthread and mutex</h2><p>basic actions of mutex:</p>
<p><code>pthread_mutex_init</code><br><code>pthread_mutex_lock</code><br><code>pthread_mutex_unlock</code><br><code>pthread_mutex_destroy</code></p>
<p><img src="/images/image34.png" alt="alt text"></p>
<h2 id="experiment-to-test-different-lock"><a href="#experiment-to-test-different-lock" class="headerlink" title="experiment to test different lock"></a>experiment to test different lock</h2><p>Here is hash realized by array.</p>
<p>without lock:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10007 <span class="comment">// size of the hash table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_OPERATIONS 10000000 <span class="comment">// total number of operations to perform</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_THREADS 10 <span class="comment">// number of threads to use</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_RATIO 0.8 <span class="comment">// ratio of read operations (rest are write and delete)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">node_t</span>* table[TABLE_SIZE]; <span class="comment">// array of linked lists, one for each hash bucket</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hash_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        table[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hash_insert</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    <span class="type">node_t</span>* new_node = (<span class="type">node_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    new_node-&gt;key = key;</span><br><span class="line">    new_node-&gt;value = value;</span><br><span class="line">    new_node-&gt;next = table[index];</span><br><span class="line">    table[index] = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash_search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    <span class="type">node_t</span>* current = table[index];</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;key == key) &#123;</span><br><span class="line">            <span class="type">int</span> value = current-&gt;value;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hash_delete</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    <span class="type">node_t</span>* current = table[index];</span><br><span class="line">    <span class="type">node_t</span>* previous = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (previous == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                table[index] = current-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                previous-&gt;next = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(current);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>) + (<span class="type">long</span>)arg); <span class="comment">// seed random number generator</span></span><br><span class="line">    <span class="type">int</span> n_reads = <span class="number">0</span>, n_writes = <span class="number">0</span>, n_deletes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> start_time, end_time;</span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;start_time); <span class="comment">// start timer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_OPERATIONS / N_THREADS; i++) &#123;</span><br><span class="line">        <span class="type">double</span> p = (<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; READ_RATIO) &#123;</span><br><span class="line">            <span class="type">int</span> key = <span class="built_in">rand</span>() % N_OPERATIONS; <span class="comment">// assume keys are integers in [0, N_OPERATIONS)</span></span><br><span class="line">            <span class="built_in">hash_search</span>(key);</span><br><span class="line">            n_reads++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">            <span class="type">int</span> key = <span class="built_in">rand</span>() % N_OPERATIONS;</span><br><span class="line">            <span class="type">int</span> value = <span class="built_in">rand</span>() % <span class="number">1000</span>; <span class="comment">// assume values are integers in [0, 1000)</span></span><br><span class="line">            <span class="built_in">hash_insert</span>(key, value);</span><br><span class="line">            n_writes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> key = <span class="built_in">rand</span>() % N_OPERATIONS;</span><br><span class="line">            <span class="built_in">hash_delete</span>(key);</span><br><span class="line">            n_deletes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;end_time); <span class="comment">// end timer</span></span><br><span class="line">    <span class="type">double</span> elapsed_time = (end_time.tv_sec - start_time.tv_sec) + <span class="number">1e-9</span> * (end_time.tv_nsec - start_time.tv_nsec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld finished: %.0f reads/sec, %.0f writes/sec, %.0f deletes/sec\n&quot;</span>, (<span class="type">long</span>)arg, n_reads / elapsed_time, n_writes / elapsed_time, n_deletes / elapsed_time);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[N_THREADS];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hash_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> start_time, end_time;</span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;start_time); <span class="comment">// start timer</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ids[N_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_THREADS; i++) &#123;</span><br><span class="line">        ids[i] = i;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, worker, (<span class="type">void</span>*)(<span class="type">long</span>)ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_THREADS; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;end_time); <span class="comment">// end timer</span></span><br><span class="line">    <span class="type">double</span> elapsed_time = (end_time.tv_sec - start_time.tv_sec) + <span class="number">1e-9</span> * (end_time.tv_nsec - start_time.tv_nsec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Benchmark finished in %f seconds\n&quot;</span>, elapsed_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>without lock:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 8.320094 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 7.188930 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 6.892515 seconds</span><br></pre></td></tr></table></figure>

<p>average time is about 7.467 seconds</p>
<h3 id="use-mutex"><a href="#use-mutex" class="headerlink" title="use mutex"></a>use mutex</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10007 <span class="comment">// size of the hash table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_OPERATIONS 10000000 <span class="comment">// total number of operations to perform</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_THREADS 10 <span class="comment">// number of threads to use</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_RATIO 0.8 <span class="comment">// ratio of read operations (rest are write and delete)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">node_t</span>* table[TABLE_SIZE]; <span class="comment">// array of linked lists, one for each hash bucket</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock[TABLE_SIZE]; <span class="comment">// mutex locks for each bucket</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        table[i] = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_mutex_init(&amp;lock[i], <span class="literal">NULL</span>); <span class="comment">// initialize mutex for each bucket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_insert</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_mutex_lock(&amp;lock[index]); <span class="comment">// acquire lock for the bucket</span></span><br><span class="line">    <span class="type">node_t</span>* new_node = (<span class="type">node_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    new_node-&gt;key = key;</span><br><span class="line">    new_node-&gt;value = value;</span><br><span class="line">    new_node-&gt;next = table[index];</span><br><span class="line">    table[index] = new_node;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock[index]); <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// we need to unlock before return, so I change two return </span></span><br><span class="line"><span class="comment">/// into only one return so that we can unlock the lock before return</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash_search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_mutex_lock(&amp;lock[index]); <span class="comment">// acquire lock for the bucket</span></span><br><span class="line">    <span class="type">node_t</span>* current = table[index];</span><br><span class="line">    <span class="type">int</span> value = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;key == key) &#123;</span><br><span class="line">            value = current-&gt;value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock[index]); <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_mutex_lock(&amp;lock[index]); <span class="comment">// acquire lock for the bucket</span></span><br><span class="line">    <span class="type">node_t</span>* current = table[index];</span><br><span class="line">    <span class="type">node_t</span>* previous = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (previous == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                table[index] = current-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                previous-&gt;next = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(current);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock[index]); <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>) + (<span class="type">long</span>)arg); <span class="comment">// seed random number generator</span></span><br><span class="line">    <span class="type">int</span> n_reads = <span class="number">0</span>, n_writes = <span class="number">0</span>, n_deletes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>, <span class="title">end_time</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start_time); <span class="comment">// start timer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_OPERATIONS / N_THREADS; i++) &#123;</span><br><span class="line">        <span class="type">double</span> p = (<span class="type">double</span>)rand() / RAND_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; READ_RATIO) &#123;</span><br><span class="line">            <span class="type">int</span> key = rand() % N_OPERATIONS; <span class="comment">// assume keys are integers in [0, N_OPERATIONS)</span></span><br><span class="line">            hash_search(key);</span><br><span class="line">            n_reads++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">            <span class="type">int</span> key = rand() % N_OPERATIONS;</span><br><span class="line">            <span class="type">int</span> value = rand() % <span class="number">1000</span>; <span class="comment">// assume values are integers in [0, 1000)</span></span><br><span class="line">            hash_insert(key, value);</span><br><span class="line">            n_writes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> key = rand() % N_OPERATIONS;</span><br><span class="line">            hash_delete(key);</span><br><span class="line">            n_deletes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end_time); <span class="comment">// end timer</span></span><br><span class="line">    <span class="type">double</span> elapsed_time = (end_time.tv_sec - start_time.tv_sec) + <span class="number">1e-9</span> * (end_time.tv_nsec - start_time.tv_nsec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld finished: %.0f reads/sec, %.0f writes/sec, %.0f deletes/sec\n&quot;</span>, (<span class="type">long</span>)arg, n_reads / elapsed_time, n_writes / elapsed_time, n_deletes / elapsed_time);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[N_THREADS];</span><br><span class="line"></span><br><span class="line">    hash_init();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>, <span class="title">end_time</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start_time); <span class="comment">// start timer</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ids[N_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_THREADS; i++) &#123;</span><br><span class="line">        ids[i] = i;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker, (<span class="type">void</span>*)(<span class="type">long</span>)ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end_time); <span class="comment">// end timer</span></span><br><span class="line">    <span class="type">double</span> elapsed_time = (end_time.tv_sec - start_time.tv_sec) + <span class="number">1e-9</span> * (end_time.tv_nsec - start_time.tv_nsec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Benchmark finished in %f seconds\n&quot;</span>, elapsed_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;lock[i]); <span class="comment">// destroy mutex for each bucket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mutex:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 7.895764 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 8.734200 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 8.333789 seconds</span><br></pre></td></tr></table></figure>

<p>average time is about 8.321 seconds</p>
<h3 id="use-rwlock"><a href="#use-rwlock" class="headerlink" title="use rwlock"></a>use rwlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">node_t</span> *table[TABLE_SIZE];          <span class="comment">// array of linked lists, one for each hash bucket</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> locks[TABLE_SIZE]; <span class="comment">// 为每个桶添加读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        table[i] = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_rwlock_init(&amp;locks[i], <span class="literal">NULL</span>); <span class="comment">// 初始化每个桶的读写锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_insert</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;locks[index]); <span class="comment">// 获取写锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// insert the node</span></span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;locks[index]); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash_search</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;locks[index]); <span class="comment">// 获取读锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// search the node</span></span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;locks[index]); <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_delete</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;locks[index]); <span class="comment">// 获取写锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete the node</span></span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;locks[index]); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[N_THREADS];</span><br><span class="line"></span><br><span class="line">    hash_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start working...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy locks (optional, as program is exiting)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_destroy(&amp;locks[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rwlock:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 7.872260 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 7.832486 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 8.129092 seconds</span><br></pre></td></tr></table></figure>

<p>average time is about 7.945 seconds</p>
<h3 id="use-spinlock"><a href="#use-spinlock" class="headerlink" title="use spinlock"></a>use spinlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">node_t</span> *table[TABLE_SIZE];            <span class="comment">// array of linked lists, one for each hash bucket</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> locks[TABLE_SIZE]; <span class="comment">// 为每个桶添加读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        table[i] = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_spin_init(&amp;locks[i], PTHREAD_PROCESS_PRIVATE); <span class="comment">// 初始化每个桶的读写锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_insert</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_spin_lock(&amp;locks[index]); <span class="comment">// 获取写锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// insert the node</span></span><br><span class="line"></span><br><span class="line">    pthread_spin_unlock(&amp;locks[index]); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash_search</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_spin_lock(&amp;locks[index]); <span class="comment">// 获取读锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// search the node</span></span><br><span class="line"></span><br><span class="line">    pthread_spin_unlock(&amp;locks[index]); <span class="comment">// 释放读锁</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_delete</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = key % TABLE_SIZE;</span><br><span class="line">    pthread_spin_lock(&amp;locks[index]); <span class="comment">// 获取写锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete the node</span></span><br><span class="line"></span><br><span class="line">    pthread_spin_unlock(&amp;locks[index]); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hash_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start working...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// destroy locks</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_spin_destroy(&amp;locks[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spinlock:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 8.171603 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 7.480587 seconds</span><br><span class="line">...</span><br><span class="line">Benchmark finished <span class="keyword">in</span> 7.168322 seconds</span><br></pre></td></tr></table></figure>

<p>average time is about 7.607 seconds</p>
<h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>When read ratio is 80%, the average time of different locks is:</p>
<table>
<thead>
<tr>
<th>without lock</th>
<th>with mutex</th>
<th>with rwlock</th>
<th>with spinlock</th>
</tr>
</thead>
<tbody><tr>
<td>7.467s</td>
<td>8.321s</td>
<td>7.945s</td>
<td>7.607s</td>
</tr>
</tbody></table>
<ul>
<li>without lock is the fastest, but it is not thread-safe.</li>
<li>mutex is the slowest, because it will block the thread which acquires kernel switch.</li>
<li>rwlock is faster than mutex, because it allows multiple threads to read at the same time.</li>
<li>spinlock is faster than mutex, because it is suitable for short time waiting. However, it is not suitable for long time waiting situation, because it will consume CPU resources.</li>
</ul>
<p>When read ratio is 90%, the average time of different locks is:</p>
<table>
<thead>
<tr>
<th>without lock</th>
<th>with mutex</th>
<th>with rwlock</th>
<th>with spinlock</th>
</tr>
</thead>
<tbody><tr>
<td>4.296s</td>
<td>4.631s</td>
<td>4.516s</td>
<td>4.595s</td>
</tr>
</tbody></table>
<p>we can see that when read ratio get higher, the performance of rwlock improves.</p>
<h2 id="linklist-example"><a href="#linklist-example" class="headerlink" title="linklist example"></a>linklist example</h2><p>Here is linklist with lock:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node *top = <span class="literal">NULL</span>; <span class="comment">// 栈顶初始化为NULL</span></span><br><span class="line"><span class="type">int</span> SLIDE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Node **top_ptr, Node *n)</span> &#123;</span><br><span class="line">    n-&gt;next = *top_ptr;</span><br><span class="line">    *top_ptr = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Node **top_ptr, Node *n)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    push(top_ptr, n);</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">pop</span><span class="params">(Node **top_ptr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*top_ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = *top_ptr;</span><br><span class="line">    *top_ptr = (*top_ptr)-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SLIDE; i++) &#123;</span><br><span class="line">        Node *new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        new_node-&gt;value = *(<span class="type">int</span>*)arg * SLIDE + i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to allocate memory for new node&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        safe_push(&amp;top, new_node); <span class="comment">// 可以把这句换成普通的push，感受一下非线程安全的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> thread_args[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n mutex init failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        thread_args[i] = i;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span> *)&amp;thread_args[i])) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to create the thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print</span></span><br><span class="line">    Node *current = top;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;content of stack:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;, current-&gt;value);</span></span><br><span class="line">        current = current-&gt;next; <span class="comment">// 假设每个节点都有一个指向下一个节点的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can use atomic instead of mutex:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">_Atomic</span> Node *top = <span class="literal">NULL</span>; </span><br><span class="line"><span class="type">int</span> SLIDE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(<span class="keyword">_Atomic</span> Node **top_ptr, Node *n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *old_top;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        old_top = <span class="type">atomic_load</span>(top_ptr);</span><br><span class="line">        n-&gt;next = old_top;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!atomic_compare_exchange_weak(top_ptr, &amp;old_top, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">safe_pop</span><span class="params">(<span class="keyword">_Atomic</span> Node **top_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *old_top;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        old_top = <span class="type">atomic_load</span>(top_ptr);</span><br><span class="line">        <span class="keyword">if</span> (old_top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!atomic_compare_exchange_weak(top_ptr, &amp;old_top, old_top-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> old_top;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>the atomic action in fact use <code>while</code> to wait for the lock, so it is not suitable for long time waiting situation.</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/xudong7?tab=repositories">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-and-mutex"><span class="toc-number">1.</span> <span class="toc-text">atomic and mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-in-GCC"><span class="toc-number">2.</span> <span class="toc-text">atomic in GCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-in-C"><span class="toc-number">3.</span> <span class="toc-text">atomic in C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-in-C-1"><span class="toc-number">4.</span> <span class="toc-text">atomic in C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-and-mutex"><span class="toc-number">5.</span> <span class="toc-text">pthread and mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#experiment-to-test-different-lock"><span class="toc-number">6.</span> <span class="toc-text">experiment to test different lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#use-mutex"><span class="toc-number">6.1.</span> <span class="toc-text">use mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-rwlock"><span class="toc-number">6.2.</span> <span class="toc-text">use rwlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-spinlock"><span class="toc-number">6.3.</span> <span class="toc-text">use spinlock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conclusion"><span class="toc-number">7.</span> <span class="toc-text">conclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linklist-example"><span class="toc-number">8.</span> <span class="toc-text">linklist example</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://xudong7.github.io/2025/04/23/atomic-and-mutex/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&text=atomic and mutex"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&is_video=false&description=atomic and mutex"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=atomic and mutex&body=Check out this article: https://xudong7.github.io/2025/04/23/atomic-and-mutex/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&title=atomic and mutex"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&name=atomic and mutex&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://xudong7.github.io/2025/04/23/atomic-and-mutex/&t=atomic and mutex"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Dunjia
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/xudong7?tab=repositories">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
